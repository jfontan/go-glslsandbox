package glsl

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

var (
	effectSimpleJSON   = `{ "_id" : 55961, "created_at" : { "$date" : 1562492504212 }, "image_url" : "thumbs/55961.png", "modified_at" : { "$date" : 1562492504212 }, "parent" : 55848, "parent_version" : 1, "user" : "d4dd013", "versions" : [ { "created_at" : { "$date" : 1562492504212 }, "code" : "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 dir;\n};\n\nfloat sphereDistance(vec3 pos) {\n\t// const vec3 spherePos = vec3(0.0, 0.0, 3.0);\n\tconst float radius = 1.0;\n\treturn length(mod(pos, 4.0) - 2.0) - radius;\n}\n\nvec3 sphereNormal(vec3 pos) {\n  float d = 0.001;\n  return normalize(vec3(\n    sphereDistance(pos - vec3(d, 0.0, 0.0)) - sphereDistance(pos),\n    sphereDistance(pos - vec3(0.0, d, 0.0)) - sphereDistance(pos),\n    sphereDistance(pos - vec3(0.0, 0.0, d)) - sphereDistance(pos)\n  ));\n}\n\t\n\nvoid main(void) {\n\tvec2 pos = (gl_FragCoord.xy * 2.0 - resolution) / resolution.y + mouse - vec2(0.5);\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -4.0 + time);\n\tvec3 cameraUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 cameraDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 cameraSide = normalize(cross(cameraUp, cameraDir));\n\t\n\tRay ray;\n\tray.pos = cameraPos;\n\tray.dir = normalize(pos.x * cameraSide + pos.y * cameraUp + cameraDir);\n\t\n\tfloat t = 0.0, d;\n\tfor(int i = 0; i < 64; i++) {\n\t\td = sphereDistance(ray.pos);\n\t\tif(d < 0.001)\tbreak;\n\t\tt += d;\n\t\tray.pos = cameraPos + t * ray.dir;\n\t}\n\t\n\tif(d < 0.001) {\n\t\tvec3 light = normalize(vec3(0.3, -1.0*sin(time), 0.0));\n\t\tvec3 normal = sphereNormal(ray.pos);\n\t\tvec3 lightColor = vec3(sin(time),cos(time*2.),sin(time*3.));\n\t\tvec3 I = dot(normal, light) * lightColor;\n\t\tgl_FragColor = vec4(I, 1.0);\n\t}\n\telse {\n\t\tgl_FragColor = vec4(0.0);\n\t}\n}" } ] }`
	effectSimpleEffect = Effect{
		ID:            55961,
		Created:       time.Unix(1562492504, 212*1000000),
		Modified:      time.Unix(1562492504, 212*1000000),
		ParentID:      55848,
		ParentVersion: 1,
		User:          "d4dd013",
		Versions: []Version{
			{
				Number:  0,
				Created: time.Unix(1562492504, 212*1000000),
				Code:    "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 dir;\n};\n\nfloat sphereDistance(vec3 pos) {\n\t// const vec3 spherePos = vec3(0.0, 0.0, 3.0);\n\tconst float radius = 1.0;\n\treturn length(mod(pos, 4.0) - 2.0) - radius;\n}\n\nvec3 sphereNormal(vec3 pos) {\n  float d = 0.001;\n  return normalize(vec3(\n    sphereDistance(pos - vec3(d, 0.0, 0.0)) - sphereDistance(pos),\n    sphereDistance(pos - vec3(0.0, d, 0.0)) - sphereDistance(pos),\n    sphereDistance(pos - vec3(0.0, 0.0, d)) - sphereDistance(pos)\n  ));\n}\n\t\n\nvoid main(void) {\n\tvec2 pos = (gl_FragCoord.xy * 2.0 - resolution) / resolution.y + mouse - vec2(0.5);\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -4.0 + time);\n\tvec3 cameraUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 cameraDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 cameraSide = normalize(cross(cameraUp, cameraDir));\n\t\n\tRay ray;\n\tray.pos = cameraPos;\n\tray.dir = normalize(pos.x * cameraSide + pos.y * cameraUp + cameraDir);\n\t\n\tfloat t = 0.0, d;\n\tfor(int i = 0; i < 64; i++) {\n\t\td = sphereDistance(ray.pos);\n\t\tif(d < 0.001)\tbreak;\n\t\tt += d;\n\t\tray.pos = cameraPos + t * ray.dir;\n\t}\n\t\n\tif(d < 0.001) {\n\t\tvec3 light = normalize(vec3(0.3, -1.0*sin(time), 0.0));\n\t\tvec3 normal = sphereNormal(ray.pos);\n\t\tvec3 lightColor = vec3(sin(time),cos(time*2.),sin(time*3.));\n\t\tvec3 I = dot(normal, light) * lightColor;\n\t\tgl_FragColor = vec4(I, 1.0);\n\t}\n\telse {\n\t\tgl_FragColor = vec4(0.0);\n\t}\n}",
			},
		},
	}

	effectVersionsJSON = `{ "_id" : 55954, "created_at" : { "$date" : 1562470645126 }, "image_url" : "thumbs/55954.png", "modified_at" : { "$date" : 1562486756686 }, "user" : "4900bbd", "versions" : [ { "created_at" : { "$date" : 1562470645127 }, "code" : "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#define rotateMat(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat sdSphere(vec3 p,float r){\n\treturn length(p)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 rep(vec3 p,vec3 span){\n\treturn mod(p,span)-span/2.;\n}\n\nfloat distanceFunction(vec3 pos){\n\tfloat d;\n\td=sdSphere(rep(pos,vec3(5,20,5)),2.+sin(time)/5.);\n\tvec3 boxPos=vec3(2);\n\tboxPos.xy*=rotateMat(time);\n\td=min(d,sdRoundBox(pos-vec3(0.,sin(time),20.+cos(time)*10.),vec3(1),0.));\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunction(p + vec3(  d, 0.0, 0.0)) - distanceFunction(p + vec3( -d, 0.0, 0.0)),\n        distanceFunction(p + vec3(0.0,   d, 0.0)) - distanceFunction(p + vec3(0.0,  -d, 0.0)),\n        distanceFunction(p + vec3(0.0, 0.0,   d)) - distanceFunction(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main( void ) {\n    vec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\n    vec3 cameraPos = vec3(0.,0., -10.);\n    float screenZ = 1.;\n    vec3 rayDirection = normalize(vec3(p, screenZ));\n\t\n\tvec3 light=vec3(10,0,15);\n\n\t\n    float depth = 0.0;\n\n    vec3 col = vec3(0.0);\n\tbool hit=false;\n\tconst int rayMax=200;\n\t\n    for (int i = 0; i < rayMax; i++) {\n        vec3 rayPos = cameraPos + rayDirection * depth;\n        float dist = distanceFunction(rayPos);\n\n        if (dist < 0.0001) {\n            col = (1.-float(i)/100.)*vec3(0.4);\n\t\tfloat l=length(light-rayPos);\n\t\tcol+=vec3(5,5,2)*5./l*(dot(normalize(light-rayPos),getNormal(rayPos)));\n\t\thit=true;\n            break;\n        }\n\n        depth += dist;\n    }\n\tif(!hit){\n\t\t\n\t}\n    gl_FragColor = vec4(col, 1.0);\n\t\n}" }, { "created_at" : { "$date" : 1562482181369 }, "code" : "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#define rotateMat(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec3 light;\n\nfloat sdSphere(vec3 p,float r){\n\treturn length(p)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 rep(vec3 p,vec3 span){\n\treturn mod(p,span)-span/2.;\n}\n\nfloat distanceFunction(vec3 pos){\n\tfloat d;\n\td=mix(sdSphere(rep(pos,vec3(5,20,5)),2.),sdRoundBox(rep(pos,vec3(5,20,5)),vec3(2.),0.),0.+step(0.,sin(time)));\n\tvec3 boxPos=pos;\n\tboxPos.xy*=rotateMat(time);\n\tboxPos.xz*=rotateMat(time*3.);\n\td=min(d,sdRoundBox(boxPos,vec3(1),0.));\n\t//d=min(d,sdSphere(pos-light,1.));\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunction(p + vec3(  d, 0.0, 0.0)) - distanceFunction(p + vec3( -d, 0.0, 0.0)),\n        distanceFunction(p + vec3(0.0,   d, 0.0)) - distanceFunction(p + vec3(0.0,  -d, 0.0)),\n        distanceFunction(p + vec3(0.0, 0.0,   d)) - distanceFunction(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\n\nvoid main( void ) {\n    vec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\n    vec3 cameraPos = vec3(0.,0., -10.);\n    float screenZ = 1.;\n    vec3 rayDirection = normalize(vec3(p, screenZ));\n\t\n\tlight=vec3(sin(time*2.)*10.,0,0);\n\n\t\n    float depth = 0.0;\n\n    vec3 col = vec3(0.0);\n\tbool hit=false;\n\tconst int rayMax=200;\n\t\n    for (int i = 0; i < rayMax; i++) {\n        vec3 rayPos = cameraPos + rayDirection * depth;\n        float dist = distanceFunction(rayPos);\n\n        if (dist < 0.0001) {\n            col = (1.-float(i)/100.)*vec3(0.4);\n\t\tfloat l=length(light-rayPos);\n\t\tcol+=(vec3(2,5,5)*step(0.,sin(time))+vec3(5,2,2)*step(sin(time),0.))*5./l*(dot(normalize(light-rayPos),getNormal(rayPos)));\n\t\thit=true;\n            break;\n        }\n\n        depth += dist;\n    }\n\tif(!hit){\n\t\t\n\t}\n    gl_FragColor = vec4(col, 1.0);\n\t\n}" }, { "created_at" : { "$date" : 1562486756686 }, "code" : "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#define rotateMat(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec3 light;\n\nfloat sdSphere(vec3 p,float r){\n\treturn length(p)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 rep(vec3 p,vec3 span){\n\treturn mod(p,span)-span/2.;\n}\n\nfloat mixStep(float x){\n\treturn clamp(sin(x)*10.,-1.,1.);\n}\n\nfloat distanceFunction(vec3 pos){\n\tfloat d;\n\td=mix(sdSphere(rep(pos,vec3(5,20,5)),2.),sdRoundBox(rep(pos,vec3(5,20,5)),vec3(2.),0.),0.5+mixStep(time)*0.5);\n\tvec3 boxPos=pos;\n\tboxPos.xy*=rotateMat(time);\n\tboxPos.xz*=rotateMat(time*3.);\n\td=min(d,sdRoundBox(boxPos,vec3(1),0.));\n\t//d=min(d,sdSphere(pos-light,1.));\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunction(p + vec3(  d, 0.0, 0.0)) - distanceFunction(p + vec3( -d, 0.0, 0.0)),\n        distanceFunction(p + vec3(0.0,   d, 0.0)) - distanceFunction(p + vec3(0.0,  -d, 0.0)),\n        distanceFunction(p + vec3(0.0, 0.0,   d)) - distanceFunction(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\n\nvoid main( void ) {\n    vec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\n    vec3 cameraPos = vec3(0.,0., -10.);\n    float screenZ = 1.;\n    vec3 rayDirection = normalize(vec3(p, screenZ));\n\t\n\tlight=vec3(sin(time*2.)*10.,0,0);\n\n\t\n    float depth = 0.0;\n\n    vec3 col = vec3(0.0);\n\tbool hit=false;\n\tconst int rayMax=200;\n\t\n    for (int i = 0; i < rayMax; i++) {\n        vec3 rayPos = cameraPos + rayDirection * depth;\n        float dist = distanceFunction(rayPos);\n\n        if (dist < 0.0001) {\n            col = (1.-float(i)/100.)*vec3(0.4);\n\t\tfloat l=length(light-rayPos);\n\t\tcol+=(mix(vec3(4,2,2),vec3(2,5,5),mixStep(time)))*2./l*(dot(normalize(light-rayPos),getNormal(rayPos)));\n\t\thit=true;\n            break;\n        }\n\n        depth += dist;\n    }\n\tif(!hit){\n\t\t\n\t}\n    gl_FragColor = vec4(col, 1.0);\n\t\n}" } ] }`
)

func TestLoadSimple(t *testing.T) {
	tests := []struct {
		name     string
		json     string
		expected Effect
	}{
		{
			name:     "simple",
			json:     effectSimpleJSON,
			expected: effectSimpleEffect,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			require := require.New(t)

			effect, err := LoadEffect([]byte(effectSimpleJSON))
			require.NoError(err)

			require.Equal(test.expected, *effect)
		})
	}
}
